/**
 * Session Manager
 *
 * Based on src/agents/session-manager.ts
 *
 * Core design decisions:
 *
 * 1. Why JSONL instead of a single JSON file?
 *    - JSONL (JSON Lines) stores one message per line, append-write
 *    - Advantage: Writes are O(1), no need to read the entire file and write back
 *    - Advantage: File corruption only affects a single line, better fault tolerance
 *    - Advantage: Can be monitored in real-time with tail -f
 *
 * 2. Why in-memory cache + disk persistence (dual-write)?
 *    - In-memory cache: Avoids disk reads on every get(), better performance
 *    - Disk persistence: Enables context recovery after Agent restart
 *    - Both are updated simultaneously on write to maintain consistency
 *
 * 3. Session key security handling
 *    - Users may pass malicious sessionKey (e.g. "../../../etc/passwd")
 *    - Must be sanitized to a safe filename
 */

import crypto from "node:crypto";
import fs from "node:fs/promises";
import path from "node:path";
import { acquireSessionWriteLock } from "./session-write-lock.js";

// ============== Type definitions ==============

/**
 * Message structure
 * Compatible with Anthropic API's MessageParam
 */
export interface Message {
  /** Role: user or assistant */
  role: "user" | "assistant";
  /** Content: can be plain text or multiple content blocks (including tool calls) */
  content: string | ContentBlock[];
  /** Timestamp: used for sorting and debugging */
  timestamp: number;
}

/**
 * Content block structure
 * Supports three types: text, tool call, and tool result
 */
export interface ContentBlock {
  /** Type */
  type: "text" | "tool_use" | "tool_result";
  /** Text content (when type=text) */
  text?: string;
  /** Tool call ID (generated by API when type=tool_use) */
  id?: string;
  /** Tool name (when type=tool_use) */
  name?: string;
  /** Tool input parameters (when type=tool_use) */
  input?: Record<string, unknown>;
  /** Associated tool call ID (when type=tool_result) */
  tool_use_id?: string;
  /** Tool execution result (when type=tool_result) */
  content?: string;
}

// ============== Session Entry structure ==============

export const CURRENT_SESSION_VERSION = 3;

export interface SessionHeaderEntry {
  type: "session";
  version: number;
  id: string;
  timestamp: string;
  cwd?: string;
}

export interface SessionEntryBase {
  type: string;
  id: string;
  parentId: string | null;
  timestamp: string;
}

export interface MessageEntry extends SessionEntryBase {
  type: "message";
  message: Message;
}

export interface CompactionEntry extends SessionEntryBase {
  type: "compaction";
  summary: string;
  firstKeptEntryId: string;
  tokensBefore: number;
}

export type SessionEntry = MessageEntry | CompactionEntry;
export type SessionFileEntry = SessionHeaderEntry | SessionEntry;

// Compaction summary prefix/suffix
export const COMPACTION_SUMMARY_PREFIX =
  "The conversation history before this point was compacted into the following summary:\n\n<summary>\n";
export const COMPACTION_SUMMARY_SUFFIX = "\n</summary>";

export function createCompactionSummaryMessage(summary: string, timestamp?: string | number): Message {
  const resolvedTimestamp =
    typeof timestamp === "string"
      ? new Date(timestamp).getTime()
      : typeof timestamp === "number"
        ? timestamp
        : Date.now();
  return {
    role: "user",
    content: `${COMPACTION_SUMMARY_PREFIX}${summary}${COMPACTION_SUMMARY_SUFFIX}`,
    timestamp: Number.isFinite(resolvedTimestamp) ? resolvedTimestamp : Date.now(),
  };
}

// ============== Session Manager ==============

export class SessionManager {
  /** Session file storage directory */
  private baseDir: string;

  /** Session cache (avoids repeated loading/parsing) */
  private states = new Map<string, SessionState>();

  constructor(baseDir: string = "./.gen-agent/sessions") {
    this.baseDir = baseDir;
  }

  /**
   * Get session file path
   *
   * Security: uses encodeURIComponent to encode sessionKey
   * Prevents path injection attacks (e.g. sessionKey = "../../../etc/passwd")
   */
  private getPath(sessionKey: string): string {
    const safeId = encodeURIComponent(sessionKey);
    return path.join(this.baseDir, `${safeId}.jsonl`);
  }

  private getLegacyPath(sessionKey: string): string {
    const safeId = sessionKey.replace(/[^a-zA-Z0-9_-]/g, "_");
    return path.join(this.baseDir, `${safeId}.jsonl`);
  }

  private createHeader(): SessionHeaderEntry {
    return {
      type: "session",
      version: CURRENT_SESSION_VERSION,
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      cwd: process.cwd(),
    };
  }

  /**
   * Load session history
   *
   * Reads from in-memory cache first; loads from disk on cache miss
   * This is the typical Cache-Aside pattern
   */
  async load(sessionKey: string): Promise<Message[]> {
    const state = await this.ensureState(sessionKey);
    return buildSessionContext(state);
  }

  /**
   * Append message
   *
   * Dual-write strategy:
   * 1. Update in-memory cache first (ensures subsequent get() reads immediately)
   * 2. Then append to disk (ensures persistence)
   *
   * Why appendFile instead of writeFile?
   * - appendFile is an append write, no need to read the entire file
   * - Write is O(1) regardless of file size
   */
  async append(sessionKey: string, message: Message): Promise<void> {
    const state = await this.ensureState(sessionKey);

    const entry: MessageEntry = {
      type: "message",
      id: generateId(state.byId),
      parentId: state.leafId,
      timestamp: new Date().toISOString(),
      message,
    };
    state.entries.push(entry);
    state.byId.set(entry.id, entry);
    state.messageIdByRef.set(message, entry.id);
    state.leafId = entry.id;
    if (message.role === "assistant") {
      state.hasAssistant = true;
    }
    await this.persistEntry(state, entry);
  }

  /**
   * Append compaction record
   */
  async appendCompaction(
    sessionKey: string,
    summary: string,
    firstKeptEntryId: string,
    tokensBefore: number,
  ): Promise<void> {
    const state = await this.ensureState(sessionKey);
    const entry: CompactionEntry = {
      type: "compaction",
      id: generateId(state.byId),
      parentId: state.leafId,
      timestamp: new Date().toISOString(),
      summary,
      firstKeptEntryId,
      tokensBefore,
    };
    state.entries.push(entry);
    state.byId.set(entry.id, entry);
    state.leafId = entry.id;
    await this.persistEntry(state, entry);
  }

  /**
   * Find the entryId for a given Message
   * - First tries reference mapping
   * - Falls back to timestamp + role matching
   */
  resolveMessageEntryId(sessionKey: string, message: Message): string | undefined {
    if (typeof message.content === "string") {
      const trimmed = message.content.trimStart();
      if (trimmed.startsWith(COMPACTION_SUMMARY_PREFIX)) {
        return undefined;
      }
    }
    const state = this.states.get(sessionKey);
    if (!state) {
      return undefined;
    }
    const direct = state.messageIdByRef.get(message);
    if (direct) {
      return direct;
    }
    for (const entry of state.entries) {
      if (entry.type !== "message") continue;
      if (entry.message.timestamp === message.timestamp && entry.message.role === message.role) {
        return entry.id;
      }
    }
    return undefined;
  }

  /**
   * Get session messages (in-memory only)
   * For fast reads without triggering disk IO
   */
  get(sessionKey: string): Message[] {
    const state = this.states.get(sessionKey);
    if (!state) {
      return [];
    }
    return buildSessionContext(state);
  }

  /**
   * Clear session
   * Cleans both in-memory cache and disk file
   */
  async clear(sessionKey: string): Promise<void> {
    this.states.delete(sessionKey);
    const filePath = this.getPath(sessionKey);
    try {
      await fs.unlink(filePath);
    } catch {
      // File does not exist, ignore
    }
    try {
      const legacyPath = this.getLegacyPath(sessionKey);
      if (legacyPath !== filePath) {
        await fs.unlink(legacyPath);
      }
    } catch {
      // Legacy file does not exist, ignore
    }
  }

  /**
   * List all sessions
   * Scans the directory for .jsonl files
   */
  async list(): Promise<string[]> {
    try {
      const files = await fs.readdir(this.baseDir);
      return files
        .filter((f: string) => f.endsWith(".jsonl"))
        .map((f: string) => {
          try {
            return decodeURIComponent(f.replace(".jsonl", ""));
          } catch {
            return f.replace(".jsonl", "");
          }
        });
    } catch {
      return [];
    }
  }

  private async ensureState(sessionKey: string): Promise<SessionState> {
    const cached = this.states.get(sessionKey);
    if (cached) {
      return cached;
    }

    const filePath = this.getPath(sessionKey);
    const legacyPath = this.getLegacyPath(sessionKey);
    let chosenPath = filePath;
    let state: SessionState | undefined;

    try {
      const loaded = await loadSessionFile(filePath);
      if (loaded.header) {
        state = buildStateFromEntries(filePath, loaded.header, loaded.entries);
      } else if (loaded.legacyMessages) {
        state = buildStateFromLegacy(filePath, loaded.legacyMessages);
        if (state.hasAssistant || state.entries.length > 0) {
          await rewriteSessionFile(state, this.baseDir);
          state.flushed = true;
        }
      }
    } catch {
      // ignore
    }

    if (!state) {
      try {
        const loaded = await loadSessionFile(legacyPath);
        if (loaded.header) {
          chosenPath = legacyPath;
          state = buildStateFromEntries(legacyPath, loaded.header, loaded.entries);
        } else if (loaded.legacyMessages) {
          chosenPath = legacyPath;
          state = buildStateFromLegacy(legacyPath, loaded.legacyMessages);
          if (state.hasAssistant || state.entries.length > 0) {
            await rewriteSessionFile(state, this.baseDir);
            state.flushed = true;
          }
        }
      } catch {
        // ignore
      }
    }

    if (!state) {
      const header = this.createHeader();
      state = {
        filePath: chosenPath,
        header,
        entries: [],
        byId: new Map<string, SessionEntry>(),
        messageIdByRef: new WeakMap<Message, string>(),
        leafId: null,
        flushed: false,
        hasAssistant: false,
      };
    }

    this.states.set(sessionKey, state);
    return state;
  }

  private async persistEntry(state: SessionState, entry: SessionEntry): Promise<void> {
    if (!state.hasAssistant) {
      return;
    }
    // Ensure the sessions directory exists before acquiring the lock file
    await fs.mkdir(this.baseDir, { recursive: true });
    const lock = await acquireSessionWriteLock({ sessionFile: state.filePath });
    try {
      if (!state.flushed) {
        await rewriteSessionFile(state, this.baseDir, { skipLock: true });
        state.flushed = true;
        return;
      }
      await fs.appendFile(state.filePath, `${JSON.stringify(entry)}\n`);
    } finally {
      await lock.release();
    }
  }

}

type SessionState = {
  filePath: string;
  header: SessionHeaderEntry;
  entries: SessionEntry[];
  byId: Map<string, SessionEntry>;
  messageIdByRef: WeakMap<Message, string>;
  leafId: string | null;
  flushed: boolean;
  hasAssistant: boolean;
};

function generateId(byId: { has(id: string): boolean }): string {
  for (let i = 0; i < 100; i++) {
    const id = crypto.randomUUID().slice(0, 8);
    if (!byId.has(id)) return id;
  }
  return crypto.randomUUID();
}

function isSessionHeader(value: unknown): value is SessionHeaderEntry {
  if (!value || typeof value !== "object") return false;
  const header = value as SessionHeaderEntry;
  return header.type === "session" && typeof header.id === "string";
}

function isLegacyMessage(value: unknown): value is Message {
  if (!value || typeof value !== "object") return false;
  const msg = value as Message;
  if (msg.role !== "user" && msg.role !== "assistant") return false;
  if (!("content" in msg)) return false;
  return typeof msg.timestamp === "number";
}

function parseJsonlLines(content: string): unknown[] {
  const entries: unknown[] = [];
  const lines = content.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    try {
      entries.push(JSON.parse(trimmed));
    } catch {
      // Skip corrupted lines, preserve other records as much as possible
    }
  }
  return entries;
}

function buildSessionContext(state: SessionState): Message[] {
  if (state.entries.length === 0) {
    return [];
  }

  if (state.leafId === null) {
    return [];
  }

  const leaf = state.leafId ? state.byId.get(state.leafId) : state.entries[state.entries.length - 1];
  if (!leaf) {
    return [];
  }

  const path: SessionEntry[] = [];
  let current: SessionEntry | undefined = leaf;
  while (current) {
    path.unshift(current);
    current = current.parentId ? state.byId.get(current.parentId) : undefined;
  }

  let compaction: CompactionEntry | null = null;
  for (const entry of path) {
    if (entry.type === "compaction") {
      compaction = entry;
    }
  }

  const messages: Message[] = [];
  const appendMessage = (entry: SessionEntry) => {
    if (entry.type === "message") {
      messages.push(entry.message);
    }
  };

  if (compaction) {
    messages.push(createCompactionSummaryMessage(compaction.summary, compaction.timestamp));
    const compactionIdx = path.findIndex(
      (entry) => entry.type === "compaction" && entry.id === compaction.id,
    );
    let foundFirstKept = false;
    for (let i = 0; i < compactionIdx; i++) {
      const entry = path[i];
      if (entry.id === compaction.firstKeptEntryId) {
        foundFirstKept = true;
      }
      if (foundFirstKept) {
        appendMessage(entry);
      }
    }
    for (let i = compactionIdx + 1; i < path.length; i++) {
      appendMessage(path[i]);
    }
  } else {
    for (const entry of path) {
      appendMessage(entry);
    }
  }

  return messages;
}

async function loadSessionFile(
  filePath: string,
): Promise<{ header?: SessionHeaderEntry; entries: SessionEntry[]; legacyMessages?: Message[] }> {
  const content = await fs.readFile(filePath, "utf-8");
  const rawEntries = parseJsonlLines(content);

  if (rawEntries.length === 0) {
    return { entries: [] };
  }

  const [first, ...rest] = rawEntries;
  if (!isSessionHeader(first)) {
    const messages = rawEntries.filter(isLegacyMessage);
    return { entries: [], legacyMessages: messages };
  }

  const header: SessionHeaderEntry = {
    ...first,
    version: typeof first.version === "number" ? first.version : CURRENT_SESSION_VERSION,
  };
  const entries: SessionEntry[] = [];

  for (const entry of rest) {
    if (!entry || typeof entry !== "object") continue;
    const typed = entry as SessionEntry;
    if (!typed.type || typeof typed.id !== "string") continue;
    if (typed.type === "message" && (typed as MessageEntry).message) {
      entries.push(typed);
      continue;
    }
    if (
      typed.type === "compaction" &&
      typeof (typed as CompactionEntry).summary === "string" &&
      typeof (typed as CompactionEntry).firstKeptEntryId === "string"
    ) {
      entries.push(typed);
    }
  }

  return { header, entries };
}

function buildStateFromEntries(
  filePath: string,
  header: SessionHeaderEntry,
  entries: SessionEntry[],
): SessionState {
  const byId = new Map<string, SessionEntry>();
  const messageIdByRef = new WeakMap<Message, string>();
  let leafId: string | null = null;
  let hasAssistant = false;

  for (const entry of entries) {
    byId.set(entry.id, entry);
    leafId = entry.id;
    if (entry.type === "message") {
      messageIdByRef.set(entry.message, entry.id);
      if (entry.message.role === "assistant") {
        hasAssistant = true;
      }
    }
  }

  return {
    filePath,
    header,
    entries,
    byId,
    messageIdByRef,
    leafId,
    flushed: true,
    hasAssistant,
  };
}

function buildStateFromLegacy(filePath: string, messages: Message[]): SessionState {
  const header = {
    type: "session",
    version: CURRENT_SESSION_VERSION,
    id: crypto.randomUUID(),
    timestamp: new Date().toISOString(),
    cwd: process.cwd(),
  } satisfies SessionHeaderEntry;
  const entries: SessionEntry[] = [];
  const byId = new Map<string, SessionEntry>();
  const messageIdByRef = new WeakMap<Message, string>();
  let leafId: string | null = null;
  let hasAssistant = false;

  for (const message of messages) {
    const entry: MessageEntry = {
      type: "message",
      id: generateId(byId),
      parentId: leafId,
      timestamp: new Date().toISOString(),
      message: {
        role: message.role,
        content: message.content,
        timestamp: typeof message.timestamp === "number" ? message.timestamp : Date.now(),
      },
    };
    entries.push(entry);
    byId.set(entry.id, entry);
    messageIdByRef.set(entry.message, entry.id);
    leafId = entry.id;
    if (entry.message.role === "assistant") {
      hasAssistant = true;
    }
  }

  return {
    filePath,
    header,
    entries,
    byId,
    messageIdByRef,
    leafId,
    flushed: false,
    hasAssistant,
  };
}

async function rewriteSessionFile(
  state: SessionState,
  baseDir: string,
  opts?: { skipLock?: boolean },
): Promise<void> {
  await fs.mkdir(baseDir, { recursive: true });
  const lines = [state.header, ...state.entries].map((entry) => JSON.stringify(entry));
  const content = `${lines.join("\n")}\n`;
  if (opts?.skipLock) {
    await fs.writeFile(state.filePath, content);
    return;
  }
  const lock = await acquireSessionWriteLock({ sessionFile: state.filePath });
  try {
    await fs.writeFile(state.filePath, content);
  } finally {
    await lock.release();
  }
}
