/**
 * Tool System Type Definitions
 *
 * Core design:
 *
 * 1. What is a "Tool"?
 *    - A tool is the interface through which an Agent interacts with the external world
 *    - An LLM can only generate text by itself; through tools it can read/write files, execute commands, etc.
 *    - Anthropic calls this "Tool Use", OpenAI calls it "Function Calling"
 *
 * 2. Why use JSON Schema to define tool inputs?
 *    - JSON Schema is a standard format that LLMs can understand and generate conforming parameters for
 *    - The Anthropic API requires inputSchema to be in JSON Schema format
 *    - This way the LLM knows each parameter's type, whether it's required, its description, etc.
 *
 * 3. Tool execution flow:
 *    ```
 *    User: "Read the src/index.ts file"
 *         ↓
 *    LLM returns: { tool_use: { name: "read", input: { file_path: "src/index.ts" } } }
 *         ↓
 *    Agent executes: readTool.execute({ file_path: "src/index.ts" }, ctx)
 *         ↓
 *    Agent returns: { tool_result: { content: "file contents..." } }
 *         ↓
 *    LLM continues generating the final response
 *    ```
 */

import type { MemoryManager, MemorySearchResult } from "../memory.js";

// ============== Execution Context ==============

/**
 * Tool Execution Context
 *
 * Passed in each time a tool is executed, providing runtime information
 */
export interface ToolContext {
  /** Working directory: base path for file operations, prevents access outside workspace */
  workspaceDir: string;
  /** Session key: used to isolate state between different agents / sessions */
  sessionKey: string;
  /** Compatibility field: retains sessionId (for CLI/debug display) */
  sessionId?: string;
  /** Current agentId (for policy or logging) */
  agentId?: string;
  /** Memory manager (injected when memory tools are enabled) */
  memory?: MemoryManager;
  /** Memory search callback (for statistics or visualization) */
  onMemorySearch?: (results: MemorySearchResult[]) => void;
  /** Sub-agent trigger (minimal version) */
  spawnSubagent?: (params: {
    task: string;
    label?: string;
    cleanup?: "keep" | "delete";
  }) => Promise<{ runId: string; sessionKey: string }>;
  /** Abort signal: supports cancelling long-running operations */
  abortSignal?: AbortSignal;
}

// ============== Tool Definition ==============

/**
 * Tool Interface
 *
 * Generic TInput is used for type-safe parameter definitions.
 * It gets erased at runtime, but provides type hints during development.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface Tool<TInput = any> {
  /** Tool name: the LLM uses this name to invoke the tool */
  name: string;

  /** Tool description: tells the LLM what this tool does and when to use it */
  description: string;

  /**
   * JSON Schema for input parameters
   *
   * Format requirements (Anthropic API):
   * - type must be "object"
   * - properties defines the schema for each parameter
   * - required lists mandatory parameters
   *
   * Example:
   * ```
   * {
   *   type: "object",
   *   properties: {
   *     file_path: { type: "string", description: "File path" },
   *     limit: { type: "number", description: "Maximum lines" }
   *   },
   *   required: ["file_path"]
   * }
   * ```
   */
  inputSchema: {
    type: "object";
    properties: Record<string, unknown>;
    required?: string[];
  };

  /**
   * Execute function
   *
   * @param input - Parameters generated by the LLM, already JSON-parsed
   * @param ctx - Execution context
   * @returns Result string that will be returned to the LLM
   */
  execute: (input: TInput, ctx: ToolContext) => Promise<string>;
}

// ============== Tool Call Record ==============

/**
 * Tool Call Record
 * Structure parsed from the tool_use block returned by the LLM
 */
export interface ToolCall {
  /** Call ID: generated by the API, used to correlate tool_result */
  id: string;
  /** Tool name */
  name: string;
  /** Call parameters */
  input: Record<string, unknown>;
}

/**
 * Tool Execution Result
 * The tool_result block returned to the LLM
 */
export interface ToolResult {
  /** Associated tool call ID */
  toolUseId: string;
  /** Execution result content */
  content: string;
  /** Whether this is an error */
  isError?: boolean;
}
